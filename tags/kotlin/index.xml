<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kotlin on Blog Marcel Widmer </title>
    <link>/tags/Kotlin/</link>
    <description>Recent content in Kotlin on Blog Marcel Widmer </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 04 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/Kotlin/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kubernetes Hazelcast Distributed Caching</title>
      <link>/posts/2020/2020-10-04-hazelcast-k8s/</link>
      <pubDate>Sun, 04 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/2020-10-04-hazelcast-k8s/</guid>
      <description>The sample code can be found on GitHub. 1
Precondition Spring Caching with Hazelcast Kustomize Configuration Hazelcast Configuration Precondition Spring Caching with Hazelcast # Let&amp;rsquo;s get ready first our Spring Boot application with the following dependencies.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Also let&amp;rsquo;s take the hazelcast-all from com.hazelcast that include the k8s dependencies. The version 4.x.x will also support yaml configuration of hazelcast.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.hazelcast&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hazelcast-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Let&amp;rsquo;s implement a real foo service with a super Chuck Norris API for the moment.</description>
    </item>
    
    <item>
      <title>Kboot Flux Meets Soap</title>
      <link>/posts/2020/2020-05-10-kboot-flux-meets-soap/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/2020-05-10-kboot-flux-meets-soap/</guid>
      <description>This will demonstrate how we can deal with a Blocking API in a Reactive World.
The GitHb 1 sample provides a
soap-server who demonstrate the blocking downstream API. flux-client with REST API lockdown that will call the blocking SOAP endpoint and. Blockhound 2 will throw an exception. easing have an implemented from Avoiding Reactor Meltdown 3 show case how to manage Blocking API. With this approach to manage Blocking API in the same service ant not in a separate service we have all the nice features like retry filter map and so on in our Service A from the Reactive Streams API.</description>
    </item>
    
  </channel>
</rss>
