<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SpringBoot on Blog Marcel Widmer </title>
    <link>/tags/SpringBoot/</link>
    <description>Recent content in SpringBoot on Blog Marcel Widmer </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 24 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/SpringBoot/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Axon Framework - MongoDB extension</title>
      <link>/posts/2022/2022-24-09-axon-mongodb-extention/</link>
      <pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/2022/2022-24-09-axon-mongodb-extention/</guid>
      <description>Commands:
A command tells our application to do something Events:
An event is a notification of something that has happened. Query:
Queries could be simplified by storing a copy of the data in a form easily In many cases, updating the query models can happen asynchronously from processing the transaction: eventual consistency Projection :
Optimized for the specific read use-cases (e.g. screens, API methods) Many separated ones instead of one big one Use carious technologies as appropriate (RDMS, Elastic, Mongo etc.</description>
    </item>
    
    <item>
      <title>Kubernetes Hazelcast Distributed Caching</title>
      <link>/posts/2020/2020-10-04-hazelcast-k8s/</link>
      <pubDate>Sun, 04 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/2020-10-04-hazelcast-k8s/</guid>
      <description>The sample code can be found on GitHub. 1
Precondition Spring Caching with Hazelcast Kustomize Configuration Hazelcast Configuration Precondition Spring Caching with Hazelcast # Let&amp;rsquo;s get ready first our Spring Boot application with the following dependencies.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Also let&amp;rsquo;s take the hazelcast-all from com.hazelcast that include the k8s dependencies. The version 4.x.x will also support yaml configuration of hazelcast.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.hazelcast&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hazelcast-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Let&amp;rsquo;s implement a real foo service with a super Chuck Norris API for the moment.</description>
    </item>
    
    <item>
      <title>Kboot Flux Meets Soap</title>
      <link>/posts/2020/2020-05-10-kboot-flux-meets-soap/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/2020-05-10-kboot-flux-meets-soap/</guid>
      <description>This will demonstrate how we can deal with a Blocking API in a Reactive World.
The GitHb 1 sample provides a
soap-server who demonstrate the blocking downstream API. flux-client with REST API lockdown that will call the blocking SOAP endpoint and. Blockhound 2 will throw an exception. easing have an implemented from Avoiding Reactor Meltdown 3 show case how to manage Blocking API. With this approach to manage Blocking API in the same service ant not in a separate service we have all the nice features like retry filter map and so on in our Service A from the Reactive Streams API.</description>
    </item>
    
    <item>
      <title>Apache Camel with Kotlin and Spring Boot</title>
      <link>/posts/2020/2020-05-04-camel-kotlin-spring-boot/</link>
      <pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/2020-05-04-camel-kotlin-spring-boot/</guid>
      <description>Apache Camel is an open source integration framework that empowers you to quickly and easily integrate various systems consuming or producing data.
Precondition on OSX Create Project Check Camel Context File Route FTP Route Choice Route Precondition on OSX # We will also use command line ftp commands for this you need the ftp command line tool this can be installed with :
brew install inetutils Create Project # Run the following commands :</description>
    </item>
    
    <item>
      <title>Spring Cloud Gateway</title>
      <link>/posts/2020/2020-04-12-cloud-gateway-sidecar/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/2020-04-12-cloud-gateway-sidecar/</guid>
      <description>This sample show how easy you can put on an existing API the Spring Cloud Gateway as kind of SideCar where you can manage your Security, Logging etc. Or just provide an other Endpoint URL like in this sample.
Let&amp;rsquo;s create a Service with a Reactive Spring Boot Application and MongoDB and a Rest Endpoint.
We start with the MongoDB document class Customer and a ReactiveCrudRepository interface CustomerRepository
@Document data class Customer(@Id val id: String = UUID.</description>
    </item>
    
    <item>
      <title>Promoting Applications Across Environments</title>
      <link>/posts/2019/2019-08-28-multiple-project-promoting/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/2019-08-28-multiple-project-promoting/</guid>
      <description>Table of contents # Create Project Install Jenkins / Install Jenkins With CLI Add Edit Role To ServiceAccount Jenkins Add Role To Group Deploy Application Development Environment Deployment Test API Testing Environment Deployment Production Environment Deployment Jenkins Pipeline WebHooks Create Project # We are going to use the CLI to create some projects. Let&amp;rsquo;s create our projects first:
$ oc login $ oc new-project development --display-name=&amp;#34;Development Environment&amp;#34; $ oc new-project testing --display-name=&amp;#34;Testing Environment&amp;#34; $ oc new-project production --display-name=&amp;#34;Production Environment&amp;#34; $ oc new-project jenkins --display-name=&amp;#34;Jenkins CI/CD&amp;#34; Install Jenkins # Create a Jenkins in the Jenkins CI/CD project with some storage.</description>
    </item>
    
    <item>
      <title>Spring Boot Kubernetes ConfigMap</title>
      <link>/posts/2019/2019-09-18-spring-boot-k8s-configmap/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/2019-09-18-spring-boot-k8s-configmap/</guid>
      <description>Now is time to configure our microservices to send the tracing logs to Jaeger 1. The configuration opentracing.jaeger.http-sender.url in configuration application.yaml file looks like below in the sources.
opentracing: jaeger: log-spans: true http-sender: url: http://localhost:14268/api/traces The opentracing.jaeger.http-sender.url we are looking for we get form the section Get Route Host in the Jaeger post We will use the ConfigMap approach with the Spring Cloud Kubernetes{:target=&amp;quot;_blank&amp;quot;} starters.
Maven # Update Maven Configuration with Spring Cloud Kubernetes{:target=&amp;quot;_blank&amp;quot;} library.</description>
    </item>
    
    <item>
      <title>Spring Boot Kubernetes Discovery</title>
      <link>/posts/2019/2019-09-21-spring-boot-k8s-ribbon-discovery/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/2019-09-21-spring-boot-k8s-ribbon-discovery/</guid>
      <description>Spring Cloud Kubernetes Ribbon provide a mechanism to perform a client side load-balancing who is needed in a microservice architecture to allocate a list of all pods where our service is running (replicated)
This mechanism can automatically discover and reach all the endpoints of a specific service, and subsequently, it populates a Ribbon ServerList with information about the endpoints.
Let&amp;rsquo;s start by adding the spring-cloud-starter-kubernetes-ribbon dependency to our pom.xml file:</description>
    </item>
    
  </channel>
</rss>
